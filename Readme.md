# Golang API Calculator

## Общее описание
Основной код представлен в main.go, а тестирование реализовано на python, пример запроса, а также тестирование сервиса. 

Сервис доступен на http://localhost:8000

Документация в виде swagger на http://0.0.0.0:8000/swagger/index.html

Для запуска сервиса - ```go run main.go```

Для запуска в контейнере - ```docker compose up --build -d```

Для запуска тестирования - ```python3 python_code/exmaple.py``` или ```python3 python_code/test.py```  или на swagger.

# О реализации

В начале были созданы структуры для операций, где есть общая структура для двух типов операций - MathOperation, PrintOperation. То есть операции определяются и разделяются на "классы", здесь используется паттерн **команда**.

Так как значения *left* и *right* могут иметь разные типы данных - float64 (или int) и string, то они были определены как интерфейсы. Последней структурой является **ResultItem** - для результата операций.

```go
type OperationUnit struct {
  Type string `json:"type"`
}

type MathOperation struct {
  OperationUnit
  Op    string      `json:"op"`
  Var   string      `json:"var"`
  Left  interface{} `json:"left"`
  Rignt interface{} `json:"rignt"`
}

type PrintOperation struct {
  OperationUnit
  Var string `json:"var"`
}
```

Далее для обработки запросов использовался модуль net/http. Функция обработки запроса - handlePost(). По ней и стоит разбирать реализацию постепенно. Так принимая запрос в виде массива словарей(операций), он проверяется на различных проверках и декодируется, далее создается словарь(или мап) для хранения значений перменных для расчетов и массив для возвращаемых значений операции print.

```go
// Хранилище переменных в виде словаря
varsStorage := make(map[string]interface{})

// Массив возвращаемых элементов для принта
var items []ResultItem
```
Дальше в цикле проходимя по операциям, декодируем уже сами операции, и дальше определяем к какой структуре их привести, если удалось привести к одной из операций, то дальше либо расчитываем результат, либо выводим. Расчет предельно простой, по switch-case определяем математический операнд и считаем. Есть функция для определения того, какую перменную стоить взять - getValue(). Ведь в left и right могут быть разные типы данных, поэтому, если у нас число, то берем его, если строка - берем из хранилища переменных, передавая в качестве ключа название переменной.
```go
// Получение значения, определяя откуда - из строки операции или хранилища
func getValue(val interface{}, varsStorage map[string]interface{}) interface{} {
	switch v := val.(type) {
	case string:
		if value, exists := varsStorage[v]; exists {
			return value
		}
		return 0.0
	case float64:
		return v
	default:
		return 0.0
	}
}
```
В конечном итоге в исполнительной функции main() настравается сервер и также CORS - для работы фронта, в нашем случае swagger, иначе блокируются запросы.

# Результаты и примеры вывода

Для тестирования можно использовать ```python example.py```:
![](/readme_pictures/ExampleUsage.png)

При запуске ```python test.py``` теста на питоне получаем это:
![](/readme_pictures/TestResult.png)

Документация Swagger:
![](/readme_pictures/SwaggerExample.png)

# Чек-лист по требованиям
1) написан на go ✔
2) любой паттерн проектирования ✔ - команда, фабрика
3) поднимается через docker compose ✔
4) unit tests coverage > 20% ✔
5) реализует grpc и http endpoint, есть swagger ✔ - http + swagger 
6) примеры запросов и ответов ✔
7) ссылка на gh, смотрю на master, или архив с кодом ✔
8) краткая записка—документация по реализации, до двух А4, в свободной форме. pdf, md,
txt ✔