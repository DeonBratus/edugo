## 1. **Команда (Command)**
**Суть:** Инкапсуляция запросов как объектов, позволяющая параметризовать клиентов с различными запросами.

**В вашем коде:**
- Каждая операция (`calc`/`print`) представлена как отдельный объект (структура)
- Унифицированный интерфейс через поле `Type`
- Последовательное выполнение операций из списка

**Пример:**
```go
// Операция сложения как команда
{
  "type": "calc",
  "op": "+",
  "var": "result",
  "left": 5,
  "right": 3
}

// Операция печати как команда
{
  "type": "print",
  "var": "result"
}
```

**Как работает:**
1. Клиент (HTTP-запрос) отправляет набор команд в JSON
2. Сервер парсит команды в структуры `MathOperation`/`PrintOperation`
3. Выполнение через единый обработчик в цикле:
```go
for _, op := range opers {
  switch baseOp.Type {
    case "calc": // выполнить математическую команду
    case "print": // выполнить команду печати
  }
}
```

**Отличие от классической реализации:**
- Нет явного интерфейса `Command` с методом `Execute()`
- Вместо полиморфизма используется `switch` по типу операции

---

### 2. **Интерпретатор (Interpreter)**
**Суть:** Представление грамматики языка и интерпретация выражений.

**В вашем коде:**
- Выражения вида `left + right` трактуются как элементы языка
- Рекурсивное вычисление значений через `getValue()`
- Контекст выполнения (хранилище переменных)

**Пример интерпретации:**
```go
func getValue(val interface{}, varsStorage map[string]interface{}) interface{} {
  switch v := val.(type) {
    case string: // переменная из контекста
    case float64: // числовой литерал
  }
}
```

**Как работает:**
- Обработка составных выражений:
```json
{
  "left": "a",
  "right": {
    "left": 5,
    "op": "*",
    "right": "b"
  }
}
```
- Рекурсивный парсинг и вычисление значений

**Особенности:**
- Упрощённая реализация без явных классов для терминальных/нетерминальных выражений
- Контекст хранится в обычной мапе `varsStorage`

---

### 3. **Стратегия (Strategy)**
**Суть:** Определение семейства алгоритмов, инкапсуляция каждого из них и обеспечение их взаимозаменяемости.

**В вашем коде:**
- Разные математические стратегии (`+`, `-`, `*`)
- Выбор алгоритма через поле `Op`

**Пример реализации:**
```go
switch op.Op {
  case "+":
    varsStorage[op.Var] = left.(float64) + right.(float64)
  case "*":
    varsStorage[op.Var] = left.(float64) * right.(float64)
  case "-":
    varsStorage[op.Var] = left.(float64) - right.(float64)
}
```

**Аналогия с классическим Strategy:**
- `Op` выступает как идентификатор стратегии
- Каждая ветка `case` — конкретная стратегия
- Можно было бы реализовать через интерфейс:
```go
type Calculator interface {
  Calculate(a, b float64) float64
}

type AddStrategy struct{}
func (s AddStrategy) Calculate(a, b float64) float64 { return a + b }
```

**Почему текущий подход лучше для Go:**
- Меньше бойлерплейта для простых операций
- Нет необходимости в отдельных структурах для стратегий

---

### 4. **Фасад (Facade)**
**Суть:** Упрощённый интерфейс для работы со сложной подсистемой.

**В вашем коде:**
- Единая точка входа `handlePost` скрывает:
  - Парсинг JSON
  - Управление состоянием переменных
  - Обработку разных типов операций
  - Формирование результата

**Схема работы:**
```
Клиент -> [Фасад: handlePost] -> 
  -> Парсинг JSON 
  -> Обработка операций 
  -> Управление переменными 
  -> Формирование ответа
```

**Преимущества:**
- Клиенту не нужно знать о внутренней логике:
  - Как хранятся переменные
  - Как парсятся операции
  - Как выполняется сериализация результата
- Изменения внутренней реализации не затрагивают клиента

---

### Синергия паттернов
Ваш код демонстрирует **прагматичное сочетание паттернов**:
1. **Фасад** предоставляет простой HTTP-интерфейс
2. **Команды** организуют обработку операций
3. **Стратегии** реализуют вариативные вычисления
4. **Интерпретатор** обеспечивает работу с выражениями

